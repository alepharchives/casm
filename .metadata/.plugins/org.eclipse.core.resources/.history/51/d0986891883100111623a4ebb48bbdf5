/*
 * matdsl.h
 *
 *  Created on: Dec 28, 2011
 *      Author: shlomi vaknin (039014220)
 *
 *  This file declares the directives used by our dsl. actual implementations are found in matdsl.c
 */

#ifndef MATDSL_H_
#define MATDSL_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "mat.h"
#include "parser.h"

/* define the maximum number of matrices used, and declare that someone will provide them */
#define MAX_MATS 6
extern Mat Mats[];

/* this is used to extend the parser error mechanism */
#define MAT_IDENT_ERR 10
#define VERIFY_ERR 11

/* DO   - a directive that has to come first, its name parameter is interactive command the user
 	 	  can use. it is assumed that a function by this name also exists (see PF)
   OR   - a directive that enables our dsl to "choose" between different commands, name parameter as in DO
   QUIT - a directive that marks what interactive commands causes the application to quit.
   ELSE - a directive that lets us print a certain message to the user when he entered a keyword that
    	  didnt not match any of the above (DO, OR and QUIT)
*/
#define PARSE(line)  {int err=0;char*l=strip(line, " ");if(0) {}
#define TRY(name)   else if (name  (matchWordD(l, #name)  , &err)) {}
#define ELSE(msg)  else if (!err){	printf("%s\n",msg);}

/* TO_PROCESS is the first thing every dsl function has to do. essentially we will enter each
  			  function, and this directive will instruct if we actually have to perform the
  			  instruction or have to pass it to the next instruction handler */
#define TO_PROCESS if (p==NULL || *p == '\0') return NULL;

/* PF - is an abbreviation for Parser Function. this is a contract that defines a function that actually
 	 	handles an interactive command. in a better type-checked languages, DO and OR will only allow
 	 	PF function to be passed to them.
 */
#define PF(name) char* name(char* p, int* err)

/* VERIFY - makes sure that the user did not enter any extra parameters. if he did, a default error
 	 	 	will be displayed and an error code will be returned
*/
#define VERIFY { \
		if (*strip(p," ")!='\n') { \
			*err=VERIFY_ERR; \
			printf("too many parameters\n"); \
			return NULL; \
		} \
}

/* This section is rather interesting, this is how i defined the dsl's composable directives:
   each directive defines a variable that holds its information, while on the last todo can
   access all the previously defined variables. see THREE_MATRIX for example.

   FMAT - extract a matrix name out of the user input.
          this directive has to be the first in the composition chain, and can only be the first.
          n is the name of the index of the requested matrix,
          todo is a holder for more logic
*/
#define FMAT(n,todo) { \
	int n;\
	TO_PROCESS;\
	if(((p=getMatrixIndex(strip(p," "), &n, #n, err)))){\
		todo;\
	}\
	return p;\
}

/*
	MAT - extract a matrix name out of the user input, has to have a ',' before it.
		  this directive cannot be the first, but it can be composed as many times as needed,
		  each time with n being a different name if the index to the requested matrix.
		  this directive knows how to deal with input errors
*/
#define MAT(n, todo) {\
	int n;\
	if(((p=getMatrixIndex(strip(charIsE(strip(p, " "), ',', err)," "), &n, #n, err)))) {\
		todo; \
	}\
	else {\
		if (*err==CHARIS_ERR) printf("wrong parameters, %s parameter must be separated by ','\n", #n);\
		return NULL;\
	}\
}

/*
	SCALAR - extract a float number out of the user input, has to have a ',' before it.
	 	 	 this directive parses a number, storing it in n. todo is composed logic.
*/
#define SCALAR(n, todo) {\
	float n;\
	if(((p = getNumber(strip(charIsE(strip(p, " "), ',', err)," "), &n, err)))) {\
		todo; \
	}\
	else {\
		if (*err==CHARIS_ERR) printf("wrong parameters, %s parameter must be separated by ','\n", #n);\
		return NULL;\
	}\
}

/*
	OSCALAR - an Optional Scalar value. if not supplied, it defaults to 0.
*/
#define OSCALAR(n, todo) {\
	float n=0;\
	if (*strip(p," ")!='\n') { \
		p = getNumber(strip(charIsE(strip(p, " "), ',', err)," "), &n, err); \
		if (*err==CHARIS_ERR) {\
			printf("wrong parameters, %s parameter must be separated by ','\n", #n);\
			return NULL;\
		} else if (*err==NUMBER_ERR) {\
			printf("Wrong parameters, parameter %s must be a real number\n", #n);\
			return NULL;\
		}\
	}\
	todo; \
}
/* a convenience directive, that abstract the use of three matrices (add, mul, sub)
   its also a good example on how the directives above are working together:
   we get a first matrix into 'first' (FMAT(first)),
   we then compose it into getting a second matrix into 'second' (MAT(second))
   we then compose it into getting a third matrix into 'third',
   the last directive first calls VERIFY, to make sure no more parameters were given to this command,
   then a function ('todo') is being applied with all three matrices.
   notice how the last directive can access first, second and third. (a little like lambda-calculus, no? :))
   */
#define THREE_MATRIX(todo) FMAT(first, MAT(second, MAT(third, VERIFY; todo(Mats[first], Mats[second], &Mats[third]))))
#define TWO_MATRIX(todo)   FMAT(first, MAT(second, VERIFY; todo(Mats[first], &Mats[second])))

/* a helper function that will actually extract the matrix index out of the user input */
char* getMatrixIndex(char* p, int* matIndex, char* errStr, int* err);

/* finally, we declare all the directives our DSL exposes */
PF(read_mat);
PF(add_mat);
PF(sub_mat);
PF(mul_mat);
PF(trans_mat);
PF(print_mat);
PF(mul_scalar);

#endif /* MATDSL_H_ */
